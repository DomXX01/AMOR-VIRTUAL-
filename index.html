<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Rompecabezas 6x6 ‚Äî Regalo ‚ù§Ô∏è</title>
  <style>
    :root{ --bg:#fff6fb; --gap:20px; --board-size:680px; --tray-w:360px; }
    *{box-sizing:border-box}
    body{margin:0;min-height:100vh;font-family:Inter,system-ui,Arial;background:var(--bg);display:flex;align-items:center;justify-content:center;padding:24px}
    .wrap{display:flex;gap:var(--gap);align-items:flex-start}
    .board{
      width:var(--board-size); height:var(--board-size);
      background:#fff; border-radius:12px; border:3px solid #333; position:relative;
      box-shadow:0 12px 36px rgba(0,0,0,.12); overflow:hidden;
    }
    canvas#guide{position:absolute; inset:0; z-index:1; pointer-events:none; opacity:.9}
    .tray{
      width:var(--tray-w); max-width:40vw; height:var(--board-size);
      background:linear-gradient(#fff,#fffefa); border-radius:12px; border:2px dashed #d6d6d6;
      padding:12px; position:relative; overflow:auto;
    }
    .piece-canvas{
      position:absolute; touch-action:none; cursor:grab; border-radius:6px;
      box-shadow:0 8px 28px rgba(0,0,0,.16);
      user-select:none;
      transition: box-shadow .12s, transform .12s;
      will-change: left, top, transform;
    }
    .piece-canvas:active{ cursor:grabbing; transform: scale(1.02); box-shadow:0 14px 40px rgba(0,0,0,.22) }
    .controls{display:flex; gap:8px; margin-bottom:8px; align-items:center; justify-content:center}
    button{background:#ff6b92;color:#fff;border:none;padding:8px 12px;border-radius:999px;cursor:pointer;box-shadow:0 6px 18px rgba(0,0,0,.09)}
    select{padding:8px;border-radius:8px;border:1px solid #eee}
    .note{margin-top:8px;background:#fff;padding:12px;border-radius:12px;box-shadow:0 6px 18px rgba(0,0,0,.06);text-align:center}
    .watermark{position:fixed;left:12px;bottom:10px;font-size:12px;opacity:.6}
    @media (max-width:1000px){ :root{ --board-size:86vw; --tray-w:86vw } .wrap{flex-direction:column;align-items:center} .tray{max-height:48vh} }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="board" id="board">
      <canvas id="guide" width="680" height="680"></canvas>
    </div>

    <div style="display:flex;flex-direction:column;gap:12px">
      <div class="controls">
        <button id="shuffle">Mezclar</button>
        <button id="toggleGuide">Ocultar/Mostrar gu√≠a</button>
        <select id="difficulty">
          <option value="6" selected>6 √ó 6</option>
          <option value="5">5 √ó 5</option>
          <option value="4">4 √ó 4</option>
        </select>
      </div>

      <div class="tray" id="tray"></div>
      <div class="note"><strong>Nuestra historia es un rompecabezas üíï</strong>
        <div style="font-size:13px;color:#666">Arrastra las piezas libremente. Cuando una pieza se suelta cerca de su sitio, se encaja autom√°ticamente.</div>
      </div>
    </div>
  </div>

  <div class="watermark">Hecho con ‚ù§Ô∏è por Dominick</div>

<script>
/* -------- CONFIG -------- */
let ROWS = 6, COLS = 6;
const IMG_SRC = 'foto.jpg'; // coloca tu foto con este nombre en la misma carpeta
const BOARD = document.getElementById('board');
const GUIDE = document.getElementById('guide');
const TRAY  = document.getElementById('tray');
const SHUFFLE = document.getElementById('shuffle');
const TOGGLE = document.getElementById('toggleGuide');
const DIFF = document.getElementById('difficulty');

/* util */
const rand = (a,b)=> a + Math.random()*(b-a);

/* --- ajuste canvas al tama√±o real del board --- */
function fitGuide(){
  const rect = BOARD.getBoundingClientRect();
  GUIDE.width = rect.width;
  GUIDE.height = rect.height;
}
fitGuide();
window.addEventListener('resize', fitGuide);

/* --- genera mapa de pesta√±as (consistente entre vecinos) --- */
function buildTabMap(rows, cols){
  const map = Array.from({length:rows}, ()=>Array.from({length:cols}, ()=>({top:0,left:0,right:0,bottom:0})));
  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      const cell = map[r][c];
      if(r>0) cell.top = -map[r-1][c].bottom;
      if(c>0) cell.left = -map[r][c-1].right;
      cell.right = c<cols-1 ? (Math.random() < .5 ? 1 : -1) : 0;
      cell.bottom = r<rows-1 ? (Math.random() < .5 ? 1 : -1) : 0;
    }
  }
  return map;
}

/* --- dibuja la forma jigsaw para una pieza (lado s) en ctx --- */
function piecePath(ctx, s, tabs){
  const tab = s * 0.32;
  const tc = tab * 0.55;
  ctx.beginPath();
  ctx.moveTo(0,0);
  // top
  if(tabs.top===0) ctx.lineTo(s,0);
  else {
    const dir = tabs.top;
    ctx.lineTo(s*0.25,0);
    ctx.bezierCurveTo(s*0.30,0, s*0.30, -dir*tc, s*0.5, -dir*tc);
    ctx.bezierCurveTo(s*0.70, -dir*tc, s*0.70, 0, s*0.75,0);
    ctx.lineTo(s,0);
  }
  // right
  if(tabs.right===0) ctx.lineTo(s,s);
  else {
    const dir = tabs.right;
    ctx.lineTo(s,s*0.25);
    ctx.bezierCurveTo(s, s*0.30, s+dir*tc, s*0.30, s+dir*tc, s*0.5);
    ctx.bezierCurveTo(s+dir*tc, s*0.70, s, s*0.70, s, s*0.75);
    ctx.lineTo(s,s);
  }
  // bottom
  if(tabs.bottom===0) ctx.lineTo(0,s);
  else {
    const dir = tabs.bottom;
    ctx.lineTo(s*0.75,s);
    ctx.bezierCurveTo(s*0.70,s, s*0.70, s+dir*tc, s*0.5, s+dir*tc);
    ctx.bezierCurveTo(s*0.30, s+dir*tc, s*0.30, s, s*0.25, s);
    ctx.lineTo(0,s);
  }
  // left
  if(tabs.left===0) ctx.lineTo(0,0);
  else {
    const dir = tabs.left;
    ctx.lineTo(0,s*0.75);
    ctx.bezierCurveTo(0, s*0.70, -dir*tc, s*0.70, -dir*tc, s*0.5);
    ctx.bezierCurveTo(-dir*tc, s*0.30, 0, s*0.30, 0, s*0.25);
    ctx.lineTo(0,0);
  }
  ctx.closePath();
}

/* --- carga imagen y crea puzzle --- */
const img = new Image();
img.src = IMG_SRC;
img.onload = ()=> initPuzzle(img);
img.onerror = ()=> alert('No se pudo cargar foto.jpg. Aseg√∫rate de que est√© en la misma carpeta y se llame foto.jpg.');

/* piezas almacenadas aqu√≠ */
let pieces = [];

function initPuzzle(image){
  ROWS = parseInt(DIFF.value) || ROWS;
  COLS = ROWS;

  fitGuide();
  const boardRect = BOARD.getBoundingClientRect();
  const boardSize = Math.min(boardRect.width, boardRect.height);
  const pieceSide = Math.floor(boardSize / COLS);

  // generar mapa y dibujar gu√≠a
  const map = buildTabMap(ROWS, COLS);
  const gctx = GUIDE.getContext('2d');
  gctx.clearRect(0,0,GUIDE.width,GUIDE.height);
  gctx.save();
  const offsetX = (GUIDE.width - boardSize)/2;
  const offsetY = (GUIDE.height - boardSize)/2;
  gctx.translate(offsetX, offsetY);
  gctx.strokeStyle = 'rgba(0,0,0,0.12)';
  gctx.lineWidth = 2;
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      gctx.save();
      gctx.translate(c*pieceSide, r*pieceSide);
      piecePath(gctx, pieceSide, map[r][c]);
      gctx.stroke();
      gctx.restore();
    }
  }
  gctx.restore();

  // limpiar piezas previas
  pieces.forEach(p=>{ if(p.el && p.el.remove) p.el.remove(); });
  pieces = [];

  // crear canvas por pieza
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      const tabs = map[r][c];
      const pad = Math.ceil(pieceSide * 0.55); // espacio para las pesta√±as
      const cw = pieceSide + pad*2;
      const ch = pieceSide + pad*2;
      const canvas = document.createElement('canvas');
      canvas.width = cw; canvas.height = ch;
      canvas.className = 'piece-canvas';
      canvas.style.width = cw + 'px';
      canvas.style.height = ch + 'px';
      canvas.style.position = 'absolute';

      // posici√≥n inicial: en pila (tray) a la derecha (luego se re-colocan)
      canvas.style.left = (boardRect.right + 20 + rand(0,180)) + 'px';
      canvas.style.top  = (boardRect.top + rand(0,boardRect.height - ch - 20)) + 'px';

      const ctx = canvas.getContext('2d');
      ctx.translate(pad, pad);
      piecePath(ctx, pieceSide, tabs);
      ctx.clip();

      // calcular porci√≥n de imagen (fuente)
      const sx = Math.floor((c * image.width) / COLS);
      const sy = Math.floor((r * image.height) / ROWS);
      const sw = Math.ceil(image.width / COLS);
      const sh = Math.ceil(image.height / ROWS);

      // dibujar la imagen escalada dentro de la pieza
      ctx.drawImage(image, sx, sy, sw, sh, 0, 0, pieceSide, pieceSide);

      // contorno blanco externo (est√©tica cl√°sica)
      ctx.save();
      ctx.lineWidth = 6;
      ctx.strokeStyle = 'rgba(255,255,255,0.95)';
      ctx.stroke();
      ctx.restore();

      // borde sutil
      ctx.strokeStyle = 'rgba(0,0,0,0.08)';
      ctx.lineWidth = 2;
      ctx.stroke();

      document.body.appendChild(canvas);

      // target absoluto donde debe ir la pieza (document coords)
      const targetX = boardRect.left + c*pieceSide - pad;
      const targetY = boardRect.top  + r*pieceSide - pad;

      pieces.push({
        el: canvas,
        r, c,
        pad,
        placed: false,
        targetX, targetY,
        width: cw, height: ch
      });
    }
  }

  // colocar en pila (tray) con rotaciones peque√±as
  layoutPile();

  // activar drag
  enableDrag();

  // eventos UI
  SHUFFLE.onclick = ()=> { layoutPile(); };
  TOGGLE.onclick = ()=> { GUIDE.style.display = (GUIDE.style.display === 'none') ? 'block' : 'none'; };
  DIFF.onchange = ()=> { location.reload(); };

  // actualizar targets al redimensionar (para snap correct)
  window.addEventListener('resize', () => {
    const br = BOARD.getBoundingClientRect();
    const ps = Math.floor(Math.min(br.width, br.height) / COLS);
    pieces.forEach(p => {
      p.targetX = br.left + p.c*ps - p.pad;
      p.targetY = br.top  + p.r*ps - p.pad;
    });
  });
}

/* coloca piezas en pila */
function layoutPile(){
  const boardRect = BOARD.getBoundingClientRect();
  const trayLeft = boardRect.right + 18;
  const trayTop  = boardRect.top + 12;
  const trayH = boardRect.height - 24;
  pieces.forEach((p,i) => {
    p.placed = false;
    p.el.style.position = 'absolute';
    const rot = rand(-22,22);
    p.el.style.transform = `rotate(${rot}deg)`;
    p.el.style.left = (trayLeft + rand(6, 200)) + 'px';
    p.el.style.top  = (trayTop  + rand(6, trayH - p.height - 20)) + 'px';
    p.el.style.zIndex = 100 + i;
    p.el.classList.remove('placed');
  });
}

/* drag con pointer events ‚Äî soporta touch + mouse */
function enableDrag(){
  let active = null;
  pieces.forEach((p, idx) => {
    const el = p.el;
    // ensure absolute numeric left/top exist
    if(!el.style.left) el.style.left = el.getBoundingClientRect().left + 'px';
    if(!el.style.top)  el.style.top  = el.getBoundingClientRect().top  + 'px';

    el.onpointerdown = (ev) => {
      if(p.placed) return; // pieza ya encajada no se puede mover
      el.setPointerCapture(ev.pointerId);
      const rect = el.getBoundingClientRect();
      active = { p, offsetX: ev.clientX - rect.left, offsetY: ev.clientY - rect.top, startZ: el.style.zIndex };
      el.style.zIndex = 9999;
      el.style.transition = 'none';
    };

    el.onpointermove = (ev) => {
      if(!active || active.p !== p) return;
      const x = ev.clientX - active.offsetX;
      const y = ev.clientY - active.offsetY;
      el.style.left = x + 'px';
      el.style.top  = y + 'px';
    };

    el.onpointerup = (ev) => {
      if(!active || active.p !== p) return;
      try { el.releasePointerCapture(ev.pointerId); } catch(e){}
      el.style.transition = '';
      // snap test: si est√° suficientemente cerca de su target -> encaja
      const rect = el.getBoundingClientRect();
      const dx = rect.left - p.targetX;
      const dy = rect.top  - p.targetY;
      const dist = Math.hypot(dx, dy);
      // tolerancia proporcional al tama√±o de la pieza
      const tolerance = Math.max(24, Math.min(p.width, p.height) * 0.28);
      if(dist < tolerance){
        // mover exactamente a target y bloquear
        el.style.left = p.targetX + 'px';
        el.style.top  = p.targetY + 'px';
        el.style.transform = 'rotate(0deg)';
        el.style.zIndex = 200;
        p.placed = true;
        el.classList.add('placed');
        // opcional: bajar opacidad o poner borde para indicar ajuste
        el.style.boxShadow = '0 6px 18px rgba(0,0,0,.08)';
        checkWin();
      } else {
        // dejar donde qued√≥ (libre)
        el.style.zIndex = 100 + idx;
      }
      active = null;
    };
  });
}

/* check si ya complet√≥ todo */
function checkWin(){
  if(pieces.length > 0 && pieces.every(p => p.placed)){
    // celebrar
    for(let i=0;i<40;i++) setTimeout(()=> spawnHeart(), i*60);
    setTimeout(()=> alert('üéâ ¬°Completaste el rompecabezas! ‚ù§Ô∏è'), 250);
  }
}

/* peque√±as animaciones de coraz√≥n */
function spawnHeart(){
  const d = document.createElement('div');
  d.textContent = Math.random()>.5 ? '‚ù§' : 'üíó';
  d.style.position = 'fixed';
  d.style.left = (20 + Math.random()*(innerWidth-40)) + 'px';
  d.style.top = innerHeight + 'px';
  d.style.fontSize = (14 + Math.random()*28) + 'px';
  d.style.pointerEvents = 'none';
  d.style.zIndex = 99999;
  document.body.appendChild(d);
  d.animate([{ transform: 'translateY(0)' }, { transform: 'translateY(-120vh)' }], { duration: 3800 + Math.random()*2000, easing:'linear' });
  setTimeout(()=> d.remove(), 6000);
}

</script>
</body>
</html>
