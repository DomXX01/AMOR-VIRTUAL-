<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Rompecabezas 6x6 ‚Äî Regalo ‚ù§Ô∏è</title>
  <style>
    :root{ --bg:#fff6fb; --board-size:680px; --tray-w:360px; --gap:28px; }
    *{box-sizing:border-box}
    body{margin:0;min-height:100vh;font-family:Inter,system-ui,Arial;background:var(--bg);display:flex;align-items:center;justify-content:center;padding:24px}
    .wrap{display:flex;gap:var(--gap);align-items:flex-start}
    .board{
      width:var(--board-size); height:var(--board-size);
      background:#fff; border-radius:14px; border:3px solid #333; position:relative;
      box-shadow:0 12px 36px rgba(0,0,0,.12); overflow:hidden;
    }
    canvas#guide{position:absolute; inset:0; z-index:1; pointer-events:none; opacity:.8}
    .tray{
      width:var(--tray-w); max-width:40vw; height:var(--board-size);
      background:linear-gradient(#fff,#fffafa); border-radius:12px; border:2px dashed #d6d6d6;
      padding:12px; position:relative; overflow:auto;
    }
    .piece-canvas{
      position:absolute; touch-action:none; cursor:grab; border-radius:6px;
      box-shadow:0 6px 22px rgba(0,0,0,.14);
      user-select:none;
    }
    .controls{display:flex; gap:8px; margin-bottom:8px; align-items:center; justify-content:center}
    button{background:#ff6b92;color:#fff;border:none;padding:8px 12px;border-radius:999px;cursor:pointer;box-shadow:0 6px 18px rgba(0,0,0,.09)}
    .note{margin-top:8px;background:#fff;padding:12px;border-radius:12px;box-shadow:0 6px 18px rgba(0,0,0,.06);text-align:center}
    .watermark{position:fixed;left:12px;bottom:10px;font-size:12px;opacity:.6}
    @media (max-width:1000px){:root{--board-size:86vw;--tray-w:86vw}.wrap{flex-direction:column;align-items:center}.tray{max-height:48vh}}
  </style>
</head>
<body>
  <div class="wrap">
    <div class="board" id="board">
      <canvas id="guide" width="680" height="680"></canvas>
    </div>

    <div style="display:flex;flex-direction:column;gap:12px">
      <div class="controls">
        <button id="shuffle">Mezclar</button>
        <button id="toggleGuide">Ocultar/Mostrar gu√≠a</button>
        <select id="difficulty">
          <option value="6" selected>6 √ó 6</option>
          <option value="5">5 √ó 5</option>
          <option value="4">4 √ó 4</option>
        </select>
      </div>

      <div class="tray" id="tray"></div>
      <div class="note"><strong>Nuestra historia es un rompecabezas üíï</strong><div style="font-size:13px;color:#666">Arrastra las piezas libremente. No hay snap autom√°tico ‚Äî es 100% manual.</div></div>
    </div>
  </div>

  <div class="watermark">Hecho con ‚ù§Ô∏è por Dominick</div>

  <script>
/*
  Instrucciones:
  1) Guarda este archivo como index.html.
  2) Coloca la foto que quieras usar como "foto.jpg" en la misma carpeta.
  3) Abre index.html en tu navegador.
*/

// CONFIG
let ROWS = 6, COLS = 6;
const IMG_SRC = 'foto.jpg'; // cambia si tu imagen tiene otro nombre
const BOARD = document.getElementById('board');
const GUIDE = document.getElementById('guide');
const TRAY  = document.getElementById('tray');
const SHUFFLE = document.getElementById('shuffle');
const TOGGLE = document.getElementById('toggleGuide');
const DIFF = document.getElementById('difficulty');

// adapt canvas to element size
function fitGuide(){
  const rect = BOARD.getBoundingClientRect();
  GUIDE.width = rect.width;
  GUIDE.height = rect.height;
}
fitGuide();
window.addEventListener('resize', fitGuide);

// util
const rand = (a,b)=> a + Math.random()*(b-a);

// TAB MAP generation: protrusions between pieces
function buildTabMap(rows, cols){
  const map = Array.from({length:rows}, ()=>Array.from({length:cols}, ()=>({top:0,left:0,right:0,bottom:0})));
  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      const cell = map[r][c];
      if(r>0) cell.top = -map[r-1][c].bottom;
      if(c>0) cell.left = -map[r][c-1].right;
      cell.right = c<cols-1 ? (Math.random() < .5 ? 1 : -1) : 0;
      cell.bottom = r<rows-1 ? (Math.random() < .5 ? 1 : -1) : 0;
    }
  }
  return map;
}

// draw jigsaw path on ctx for one piece side s (at 0,0)
function piecePath(ctx, s, tabs){
  const tab = s * 0.32;
  const tc = tab * 0.55;
  ctx.beginPath();
  ctx.moveTo(0,0);
  // top
  if(tabs.top===0) ctx.lineTo(s,0);
  else {
    const dir = tabs.top;
    ctx.lineTo(s*0.25,0);
    ctx.bezierCurveTo(s*0.30,0, s*0.30, -dir*tc, s*0.5, -dir*tc);
    ctx.bezierCurveTo(s*0.70, -dir*tc, s*0.70, 0, s*0.75,0);
    ctx.lineTo(s,0);
  }
  // right
  if(tabs.right===0) ctx.lineTo(s,s);
  else {
    const dir = tabs.right;
    ctx.lineTo(s,s*0.25);
    ctx.bezierCurveTo(s, s*0.30, s+dir*tc, s*0.30, s+dir*tc, s*0.5);
    ctx.bezierCurveTo(s+dir*tc, s*0.70, s, s*0.70, s, s*0.75);
    ctx.lineTo(s,s);
  }
  // bottom
  if(tabs.bottom===0) ctx.lineTo(0,s);
  else {
    const dir = tabs.bottom;
    ctx.lineTo(s*0.75,s);
    ctx.bezierCurveTo(s*0.70,s, s*0.70, s+dir*tc, s*0.5, s+dir*tc);
    ctx.bezierCurveTo(s*0.30, s+dir*tc, s*0.30, s, s*0.25, s);
    ctx.lineTo(0,s);
  }
  // left
  if(tabs.left===0) ctx.lineTo(0,0);
  else {
    const dir = tabs.left;
    ctx.lineTo(0,s*0.75);
    ctx.bezierCurveTo(0, s*0.70, -dir*tc, s*0.70, -dir*tc, s*0.5);
    ctx.bezierCurveTo(-dir*tc, s*0.30, 0, s*0.30, 0, s*0.25);
    ctx.lineTo(0,0);
  }
  ctx.closePath();
}

// load image
const img = new Image();
img.src = IMG_SRC;
img.onload = ()=> initPuzzle(img);
img.onerror = ()=> alert('No se pudo cargar foto.jpg. Aseg√∫rate de que est√© en la misma carpeta y se llame foto.jpg');

let pieces = []; // lista de piezas (objetos con el canvas)
function initPuzzle(image){
  ROWS = parseInt(DIFF.value) || ROWS;
  COLS = ROWS;

  fitGuide();
  const boardRect = BOARD.getBoundingClientRect();
  const boardSize = Math.min(boardRect.width, boardRect.height);
  const pieceSide = Math.floor(boardSize / COLS);

  // crear mapa
  const map = buildTabMap(ROWS, COLS);

  // dibujo de gu√≠a en canvas GUIDE
  const gctx = GUIDE.getContext('2d');
  gctx.clearRect(0,0,GUIDE.width,GUIDE.height);
  gctx.strokeStyle = 'rgba(0,0,0,0.12)';
  gctx.lineWidth = 2;

  // scale factor from image to board coordinates
  const scaleX = boardSize / image.width;
  const scaleY = boardSize / image.height;
  // we draw guide resized to boardSize
  gctx.save();
  // center guide if canvas larger
  const offsetX = (GUIDE.width - boardSize)/2;
  const offsetY = (GUIDE.height - boardSize)/2;
  gctx.translate(offsetX, offsetY);

  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      const tabs = map[r][c];
      const x = c * pieceSide;
      const y = r * pieceSide;
      gctx.save();
      gctx.translate(x, y);
      piecePath(gctx, pieceSide, tabs);
      gctx.stroke();
      gctx.restore();
    }
  }
  gctx.restore();

  // remove any prior pieces
  pieces.forEach(p=>{ if(p.el && p.el.remove) p.el.remove(); });
  pieces = [];

  // create piece canvases
  for(let r=0;r<ROWS;r++){
    for(let c=0;c<COLS;c++){
      const tabs = map[r][c];
      const pad = Math.ceil(pieceSide * 0.55); // room for tabs
      const cw = pieceSide + pad*2;
      const ch = pieceSide + pad*2;
      const canvas = document.createElement('canvas');
      canvas.width = cw; canvas.height = ch;
      canvas.className = 'piece-canvas';
      canvas.style.width = cw + 'px';
      canvas.style.height = ch + 'px';
      // start position (inside tray area)
      canvas.style.left = (BOARD.getBoundingClientRect().right + 20 + rand(0,180)) + 'px';
      canvas.style.top  = (BOARD.getBoundingClientRect().top + rand(0,200)) + 'px';

      const ctx = canvas.getContext('2d');
      ctx.translate(pad, pad);
      // clip to jigsaw shape
      piecePath(ctx, pieceSide, tabs);
      ctx.clip();

      // compute image source rectangle for this piece
      const sx = Math.floor((c * image.width) / COLS);
      const sy = Math.floor((r * image.height) / ROWS);
      const sw = Math.ceil(image.width / COLS);
      const sh = Math.ceil(image.height / ROWS);
      // draw image part scaled to pieceSide
      ctx.drawImage(image, sx, sy, sw, sh, 0, 0, pieceSide, pieceSide);

      // stroke edge to define piece
      ctx.strokeStyle = 'rgba(0,0,0,0.08)';
      ctx.lineWidth = 2;
      ctx.stroke();

      document.body.appendChild(canvas);

      const piece = {
        el: canvas,
        r, c,
        pad,
        placed:false,
        targetX: BOARD.getBoundingClientRect().left + c*pieceSide - pad,
        targetY: BOARD.getBoundingClientRect().top  + r*pieceSide - pad,
        width:cw, height:ch
      };
      pieces.push(piece);
    }
  }

  // shuffle layout in tray (pile)
  layoutPile();

  // enable dragging
  enableDrag();

  // actions
  SHUFFLE.onclick = ()=>{ layoutPile(); };
  TOGGLE.onclick = ()=>{ GUIDE.style.display = GUIDE.style.display === 'none' ? 'block' : 'none'; };
  DIFF.onchange = ()=>{ location.reload(); };
}

// place pieces in a pile (tray area at right of board)
function layoutPile(){
  const boardRect = BOARD.getBoundingClientRect();
  const trayLeft = boardRect.right + 18;
  const trayTop  = boardRect.top + 12;
  const trayH = boardRect.height - 24;
  pieces.forEach((p,i)=>{
    p.placed = false;
    p.el.style.position = 'absolute';
    // random small rotations
    const rot = rand(-18,18);
    p.el.style.transform = `rotate(${rot}deg)`;
    p.el.style.left = (trayLeft + rand(6, 200)) + 'px';
    p.el.style.top  = (trayTop  + rand(6, trayH - p.height - 20)) + 'px';
    p.el.style.zIndex = 100 + i;
    p.el.classList.remove('placed');
  });
}

// pointer drag implementation (works for touch + mouse)
function enableDrag(){
  let active = null;
  pieces.forEach((p, idx) => {
    const el = p.el;
    el.onpointerdown = (ev) => {
      el.setPointerCapture(ev.pointerId);
      const rect = el.getBoundingClientRect();
      active = { p, offsetX: ev.clientX - rect.left, offsetY: ev.clientY - rect.top };
      el.style.zIndex = 1000;
      el.style.transition = 'none';
    };
    el.onpointermove = (ev) => {
      if(!active || active.p !== p) return;
      const x = ev.clientX - active.offsetX;
      const y = ev.clientY - active.offsetY;
      el.style.left = x + 'px';
      el.style.top  = y + 'px';
    };
    el.onpointerup = (ev) => {
      if(!active || active.p !== p) return;
      try{ el.releasePointerCapture(ev.pointerId); }catch(e){}
      el.style.transition = '';
      active = null;
      el.style.zIndex = 100 + idx;
      // do NOT auto-snap ‚Äî user wants free movement
    };
  });
}

// small decorative hearts on completion
function celebrate(){
  for(let i=0;i<40;i++){
    setTimeout(()=> spawnHeart(), i*60);
  }
}
function spawnHeart(){
  const d = document.createElement('div');
  d.textContent = Math.random()>.5? '‚ù§' : 'üíó';
  d.style.position='fixed';
  d.style.left = (20 + Math.random()*(innerWidth-40)) + 'px';
  d.style.top = innerHeight + 'px';
  d.style.fontSize = (14 + Math.random()*28) + 'px';
  d.style.pointerEvents='none';
  d.style.zIndex = 9999;
  document.body.appendChild(d);
  // animate upward
  d.animate([{ transform: 'translateY(0)' }, { transform: 'translateY(-120vh)' }], { duration: 4000 + Math.random()*2000, easing:'linear' });
  setTimeout(()=> d.remove(), 6000);
}

  </script>
</body>
</html>
